package onix.modules.impl.misc;

import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import net.minecraft.network.packet.s2c.play.GameMessageS2CPacket;
import onix.events.api.EventHandler;
import onix.events.impl.KeyEvent;
import onix.events.impl.PacketEvent;
import onix.modules.module.ModuleStructure;
import onix.modules.module.category.ModuleCategory;
import onix.modules.module.setting.implement.BindSetting;
import onix.modules.module.setting.implement.SelectSetting;
import onix.modules.module.setting.implement.SliderSettings;
import onix.util.string.chat.ChatMessage;

import java.io.*;
import java.net.ServerSocket;
import java.net.Socket;
import java.security.SecureRandom;
import java.util.ArrayDeque;
import java.util.Queue;
import java.util.concurrent.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class RegionExploit extends ModuleStructure {
    private final SelectSetting mode = new SelectSetting("Режим", "").value("Приниматель", "Отправитель");
    private final SliderSettings regionRadius = new SliderSettings("Радиус региона", "").range(5, 24).setValue(10).visible(() -> mode.isSelected("Отправитель"));
    private final BindSetting sendKey = new BindSetting("Кнопка отправки", "").visible(() -> mode.isSelected("Отправитель"));

    private static final int RECEIVER_PORT = 12449;
    private static final long COMMAND_DELAY_MS = 500;
    private static final long SEND_COOLDOWN_MS = 5000;
    private static final long RETRY_DELAY_MS = 3000;

    private ServerSocket serverSocket;
    private Socket clientSocket;
    private BufferedReader reader;
    private PrintWriter writer;
    private Socket senderSocket;
    private BufferedReader senderReader;
    private PrintWriter senderWriter;
    private Thread serverThread;
    private ScheduledExecutorService scheduler;
    private boolean serverRunning;
    private boolean clientConnected;
    private boolean awaitingRegionList;
    private boolean awaitingClaim;
    private boolean awaitingLimitMessage;
    private String currentRegionName;
    private JsonObject lastReceivedMessage;
    private String lastUsername;
    private final Queue<String> commandQueue = new ArrayDeque<>();
    private long lastSendTime = 0;
    private double lastPlayerX;
    private double lastPlayerY;
    private double lastPlayerZ;
    private boolean hasLastPos;
    private final Queue<String> messageQueue = new ArrayDeque<>();
    private Thread senderThread;
    private boolean connectionMessagePrinted;
    private int currentRadius;
    private int serverLimit;

    private static final String CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    private static final SecureRandom RANDOM = new SecureRandom();

    public RegionExploit() {
        super("Region Exploit", "Автоматическое создание региона когда вы в KT", ModuleCategory.PLAYER);
        settings(mode, regionRadius, sendKey);
    }

    private String generateRegionName() {
        StringBuilder sb = new StringBuilder("rgab_");
        for (int i = 0; i < 8; i++) {
            sb.append(CHARS.charAt(RANDOM.nextInt(CHARS.length())));
        }
        return sb.toString();
    }

    @EventHandler
    public void onKey(KeyEvent event) {
        if (event.key() == sendKey.getKey() && mode.isSelected("Отправитель") && mc.player != null) {
            long currentTime = System.currentTimeMillis();
            if (currentTime - lastSendTime < SEND_COOLDOWN_MS) {
                printregion("§eПодождите, кулдаун отправки: " + (SEND_COOLDOWN_MS - (currentTime - lastSendTime)) / 1000 + " сек.");
                return;
            }
            lastSendTime = currentTime;
            JsonObject object = new JsonObject();
            JsonObject position = new JsonObject();
            position.addProperty("x", (int) mc.player.getX());
            position.addProperty("y", (int) mc.player.getY());
            position.addProperty("z", (int) mc.player.getZ());
            object.add("position", position);
            object.addProperty("radius", (int) regionRadius.getValue());
            object.addProperty("username", mc.getSession().getUsername());
            currentRadius = (int) regionRadius.getValue();
            synchronized (messageQueue) {
                messageQueue.offer(object.toString());
                printregion("§aКоординаты отправлены: " + (int) mc.player.getX() + ", " + (int) mc.player.getY() + ", " + (int) mc.player.getZ());
            }
        }
    }

    private void attemptConnectionSender() {
        try {
            senderSocket = new Socket("localhost", RECEIVER_PORT);
            senderReader = new BufferedReader(new InputStreamReader(senderSocket.getInputStream()));
            senderWriter = new PrintWriter(senderSocket.getOutputStream(), true);
            if (!connectionMessagePrinted) {
                printregion("§aУспешно подключено к принимающему клиенту!");
                connectionMessagePrinted = true;
            }
        } catch (IOException e) {
            closeSenderSocket();
        }
    }

    private void closeSenderSocket() {
        try {
            if (senderReader != null) senderReader.close();
            if (senderWriter != null) senderWriter.close();
            if (senderSocket != null) senderSocket.close();
        } catch (IOException ignored) {}
        senderSocket = null;
        senderReader = null;
        senderWriter = null;
    }

    public void startServer() {
        if (serverRunning) return;
        if (mode.isSelected("Приниматель")) {
            serverThread = new Thread(() -> {
                try {
                    serverSocket = new ServerSocket(RECEIVER_PORT);
                    serverRunning = true;
                    while (serverRunning && !Thread.currentThread().isInterrupted()) {
                        try {
                            clientSocket = serverSocket.accept();
                            reader = new BufferedReader(new InputStreamReader(clientSocket.getInputStream()));
                            writer = new PrintWriter(clientSocket.getOutputStream(), true);
                            handleClient();
                        } catch (IOException e) {
                        }
                    }
                } catch (IOException e) {
                } finally {
                    closeServerSocket();
                }
            });
            serverThread.start();
            scheduler = Executors.newScheduledThreadPool(1);
            scheduler.scheduleAtFixedRate(this::processCommandQueue, 0, COMMAND_DELAY_MS, TimeUnit.MILLISECONDS);
        }
    }

    private void handleClient() {
        new Thread(() -> {
            try {
                String line;
                while ((line = reader.readLine()) != null && serverRunning) {
                    if (!line.equals("PING")) {
                        processSocketMessage(line);
                    }
                }
            } catch (IOException e) {
            } finally {
                synchronized (this) {
                    clientConnected = false;
                }
                closeClientSocket();
            }
        }).start();
        synchronized (this) {
            if (!clientConnected) {
                clientConnected = true;
            }
        }
    }

    private void closeClientSocket() {
        try {
            if (reader != null) reader.close();
            if (writer != null) writer.close();
            if (clientSocket != null) clientSocket.close();
        } catch (IOException ignored) {}
    }

    private void processSocketMessage(String line) {
        try {
            JsonObject object = JsonParser.parseString(line).getAsJsonObject();
            lastReceivedMessage = object;
            JsonObject pos = object.getAsJsonObject("position");
            String username = object.get("username").getAsString();
            currentRadius = object.get("radius").getAsInt();
            int x = pos.get("x").getAsInt();
            int y = pos.get("y").getAsInt();
            int z = pos.get("z").getAsInt();
            lastUsername = username;
            awaitingRegionList = true;
            commandQueue.offer("/rg list");
        } catch (Exception e) {
        }
    }

    private void processCommandQueue() {
        synchronized (commandQueue) {
            if (!commandQueue.isEmpty() && mc.player != null && mode.isSelected("Приниматель")) {
                if (isPlayerStable()) {
                    String command = commandQueue.poll();
                    mc.player.networkHandler.sendChatMessage(command);
                }
            }
        }
    }

    private boolean isPlayerStable() {
        if (!mode.isSelected("Приниматель") || mc.player == null) return true;
        double currentX = mc.player.getX();
        double currentY = mc.player.getY();
        double currentZ = mc.player.getZ();
        if (hasLastPos && (currentX != lastPlayerX || currentY != lastPlayerY || currentZ != lastPlayerZ)) {
            lastPlayerX = currentX;
            lastPlayerY = currentY;
            lastPlayerZ = currentZ;
            return false;
        }
        lastPlayerX = currentX;
        lastPlayerY = currentY;
        lastPlayerZ = currentZ;
        hasLastPos = true;
        return true;
    }

    @EventHandler
    public void onPacket(PacketEvent event) {
        if (!mode.isSelected("Приниматель") || !(event.getPacket() instanceof GameMessageS2CPacket packet)) return;
        String msg = packet.content().getString();
        if (awaitingRegionList) {
            if (msg.contains("(FAWE)")) {
                awaitingRegionList = false;
                if (msg.contains("No results found.")) {
                    queueRegionCommands();
                } else {
                    Pattern pattern = Pattern.compile("\\+\\s+(rgab_\\w{8})");
                    Matcher matcher = pattern.matcher(msg);
                    while (matcher.find()) {
                        String regionName = matcher.group(1);
                        commandQueue.offer("/rg remove " + regionName);
                    }
                    CompletableFuture.runAsync(() -> {
                        try {
                            Thread.sleep(COMMAND_DELAY_MS);
                            queueRegionCommands();
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    });
                }
            }
        } else if (awaitingClaim) {
            if (msg.contains("Вы заприватили") && msg.contains(currentRegionName)) {
                awaitingClaim = false;
                commandQueue.offer("/rg addMember " + currentRegionName + " " + lastUsername);
                synchronized (this) {
                    if (writer != null) {
                        writer.println("REGION_CLAIMED");
                    }
                }
            } else if (msg.contains("Это регион перекрывает чужой регион.")) {
                synchronized (this) {
                    if (writer != null) {
                        writer.println("OVERLAP_ERROR");
                    }
                }
                awaitingClaim = false;
                commandQueue.clear();
            } else if (msg.contains("Вы не можете заприватить")) {
                awaitingLimitMessage = true;
                commandQueue.clear();
                synchronized (this) {
                    if (writer != null) {
                        writer.println("SIZE_LIMIT_ERROR");
                    }
                }
                awaitingClaim = false;
                commandQueue.clear();
            }
        } else if (awaitingLimitMessage && msg.contains("Ваш лимит:")) {
            Pattern pattern = Pattern.compile("Ваш лимит: (\\d+), вы попытались запривать: (\\d+)");
            Matcher matcher = pattern.matcher(msg);
            if (matcher.find()) {
                serverLimit = Integer.parseInt(matcher.group(1));
                if (lastReceivedMessage != null) {
                    int newRadius = calculateNewRadius(serverLimit);
                    if (newRadius >= 5 && newRadius < currentRadius) {
                        currentRadius = newRadius;
                        CompletableFuture.runAsync(() -> {
                            try {
                                Thread.sleep(RETRY_DELAY_MS);
                                queueRegionCommands();
                            } catch (InterruptedException e) {
                                Thread.currentThread().interrupt();
                            }
                        });
                    } else {
                        awaitingLimitMessage = false;
                        awaitingClaim = false;
                    }
                } else {
                    awaitingLimitMessage = false;
                    awaitingClaim = false;
                }
            }
        } else if (msg.contains("Не спамь!")) {
            synchronized (commandQueue) {
                if (!commandQueue.isEmpty()) {
                    String lastCommand = commandQueue.peek();
                    CompletableFuture.runAsync(() -> {
                        try {
                            Thread.sleep(3000);
                            commandQueue.offer(lastCommand);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    });
                }
            }
        }
    }

    private int calculateNewRadius(int limit) {
        if (lastReceivedMessage == null || !lastReceivedMessage.has("position")) {
            return 5;
        }
        JsonObject pos = lastReceivedMessage.getAsJsonObject("position");
        int x = pos.get("x").getAsInt();
        int z = pos.get("z").getAsInt();
        int newRadius = currentRadius;
        while (newRadius >= 5) {
            newRadius--;
            int x1 = x - newRadius;
            int z1 = z - newRadius;
            int x2 = x + newRadius;
            int z2 = z + newRadius;
            int size = (x2 - x1 + 1) * (z2 - z1 + 1) * 256;
            if (size <= limit) {
                return newRadius;
            }
        }
        return 5;
    }

    private void queueRegionCommands() {
        if (lastReceivedMessage == null || !lastReceivedMessage.has("position")) {
            return;
        }
        JsonObject pos = lastReceivedMessage.getAsJsonObject("position");
        int x = pos.get("x").getAsInt();
        int y = pos.get("y").getAsInt();
        int z = pos.get("z").getAsInt();
        int x1 = x - currentRadius;
        int y1 = y - currentRadius;
        int z1 = z - currentRadius;
        int x2 = x + currentRadius;
        int y2 = y + currentRadius;
        int z2 = z + currentRadius;
        commandQueue.offer("//1 " + x1 + "," + y1 + "," + z1);
        commandQueue.offer("//2 " + x2 + "," + y2 + "," + z2);
        currentRegionName = generateRegionName();
        commandQueue.offer("/rg claim " + currentRegionName);
        awaitingClaim = true;
    }

    private void closeServerSocket() {
        synchronized (this) {
            closeClientSocket();
            if (serverSocket != null && !serverSocket.isClosed()) {
                try {
                    serverSocket.close();
                } catch (IOException e) {
                }
            }
            serverSocket = null;
            serverRunning = false;
        }
    }

    @Override
    public void activate() {
        super.activate();
        serverRunning = false;
        clientConnected = false;
        awaitingRegionList = false;
        awaitingClaim = false;
        awaitingLimitMessage = false;
        lastReceivedMessage = null;
        lastUsername = null;
        lastSendTime = 0;
        hasLastPos = false;
        commandQueue.clear();
        messageQueue.clear();
        connectionMessagePrinted = false;
        serverLimit = 0;
        if (mode.isSelected("Отправитель")) {
            attemptConnectionSender();
            senderThread = new Thread(() -> {
                while (!Thread.currentThread().isInterrupted()) {
                    String message;
                    synchronized (messageQueue) {
                        message = messageQueue.poll();
                    }
                    if (message != null) {
                        try {
                            if (senderSocket == null || senderSocket.isClosed()) {
                                attemptConnectionSender();
                                if (senderSocket == null) {
                                    continue;
                                }
                            }
                            senderWriter.println(message);
                            String line;
                            while ((line = senderReader.readLine()) != null) {
                                if (line.equals("REGION_CLAIMED")) {
                                    printregion("§aРегион запривачен!");
                                } else if (line.equals("OVERLAP_ERROR")) {
                                    printregion("§cВаш регион перекрывает чужой регион, найдите другое место чтобы заприватить.");
                                } else if (line.equals("SIZE_LIMIT_ERROR")) {
                                    printregion("§cОшибка при попытке заприватить регион");
                                }
                                break;
                            }
                        } catch (IOException e) {
                            closeSenderSocket();
                            try {
                                Thread.sleep(RETRY_DELAY_MS);
                            } catch (InterruptedException ex) {
                                Thread.currentThread().interrupt();
                            }
                            attemptConnectionSender();
                        }
                    } else {
                        try {
                            Thread.sleep(50);
                        } catch (InterruptedException e) {
                            Thread.currentThread().interrupt();
                        }
                    }
                }
            });
            senderThread.start();
        } else if (mode.isSelected("Приниматель")) {
            startServer();
        }
    }

    @Override
    public void deactivate() {
        super.deactivate();
        serverRunning = false;
        clientConnected = false;
        awaitingRegionList = false;
        awaitingClaim = false;
        awaitingLimitMessage = false;
        lastReceivedMessage = null;
        lastUsername = null;
        lastSendTime = 0;
        hasLastPos = false;
        commandQueue.clear();
        messageQueue.clear();
        connectionMessagePrinted = false;
        serverLimit = 0;
        if (senderThread != null) {
            senderThread.interrupt();
        }
        if (scheduler != null) {
            scheduler.shutdown();
            try {
                if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                    scheduler.shutdownNow();
                }
            } catch (InterruptedException e) {
                scheduler.shutdownNow();
            }
        }
        closeServerSocket();
        closeSenderSocket();
    }

    private void printregion(String message) {
        ChatMessage.brandmessage(message);
    }
}